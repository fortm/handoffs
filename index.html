<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Recognition</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }

        #container {
            position: relative;
            display: inline-block;
        }

        #video {
            width: 640px;
            height: 480px;
            border: 1px solid #ccc;
            transform: scaleX(-1);
        }

        /* Mirror video */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            pointer-events: none;
            transform: scaleX(-1);
        }

        /* Mirror canvas */
        #gestureResult {
            font-size: 24px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
<h1>Hand Gesture Recognition</h1>
<div id="container">
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
</div>
<div id="gestureResult">No gesture detected</div>

<script type="module">
    import {
        FilesetResolver,
        GestureRecognizer
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/vision_bundle.mjs";

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gestureResult = document.getElementById('gestureResult');

    async function setupWebcam() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({video: true});
            video.srcObject = stream;
            video.addEventListener('loadeddata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                initRecognizer();
            });
        } catch (err) {
            console.error('Webcam error:', err);
            alert('Allow webcam access.');
        }
    }

    let recognizer;

    async function initRecognizer() {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
        );
        recognizer = await GestureRecognizer.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                delegate: "CPU"  // Fix for classifier/GPU issues
            },
            runningMode: "VIDEO",
            numHands: 2,
            minHandDetectionConfidence: 0.4,
            minHandPresenceConfidence: 0.4,
            minTrackingConfidence: 0.4
        });
        renderLoop();
    }

    let lastTime = -1;

    function renderLoop() {
        if (video.currentTime !== lastTime) {
            const results = recognizer.recognizeForVideo(video, performance.now());  // Add timestamp
            processResults(results);
            lastTime = video.currentTime;
        }
        requestAnimationFrame(renderLoop);
    }

    function processResults(results) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gestureResult.textContent = 'No gesture detected';

        if (results.landmarks) {
            results.landmarks.forEach((landmarks, i) => {
                // Draw landmarks (red dots)
                landmarks.forEach(landmark => {
                    ctx.beginPath();
                    ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                });

                // Draw skeleton connections
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],  // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8],  // Index
                    [5, 9], [9, 10], [10, 11], [11, 12],  // Middle
                    [9, 13], [13, 14], [14, 15], [15, 16],  // Ring
                    [13, 17], [17, 18], [18, 19], [19, 20],  // Pinky
                    [0, 17]  // Palm base
                ];
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                connections.forEach(([start, end]) => {
                    const s = landmarks[start];
                    const e = landmarks[end];
                    ctx.beginPath();
                    ctx.moveTo(s.x * canvas.width, s.y * canvas.height);
                    ctx.lineTo(e.x * canvas.width, e.y * canvas.height);
                    ctx.stroke();
                });

                // Display gesture
                if (results.gestures && results.gestures[i]) {
                    const gesture = results.gestures[i][0];
                    if (gesture.score > 0.4) {
                        gestureResult.textContent = `Gesture: ${gesture.categoryName} (Confidence: ${gesture.score.toFixed(2)})`;
                    }
                }
            });
        }
    }

    setupWebcam();
</script>
</body>
</html>